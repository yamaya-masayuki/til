# Metalベストプラクティス: トリプルバッファリング

[Metal Best Practices Guide: Triple Buffering](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/TripleBuffering.html)より

**ベストプラクティス**: ダイナミックバッファのデータを更新するために、トリプルバッファリングモデルを実装せよ。

ダイナミックバッファデータとは、頻繁に更新されるデータをバッファに格納することです。フレームごとに新しいバッファを作成することを避け、フレーム間のプロセッサのアイドル時間を最小にするために、トリプルバッファリングモデルを実装します。

## アクセス競合の防止とプロセッサのアイドル時間の短縮する

ダイナミックバッファーデータは、通常、CPUが書き込み、GPUが読み取ります。

これらの操作が同時に起こると、アクセス競合が発生します。CPUがデータを書き込んでからGPUがそれを読むことができ、GPUがデータを読み込んでからCPUがそれを上書きすることができるようにならなければなりません。

ダイナミックバッファデータを1つのバッファで保存する場合、CPUが停止しているか、GPUが飢餓状態にあるときに、プロセッサのアイドル時間が長くなります。

プロセッサが並列に動作するためには、CPUがGPU よりも少なくとも1フレーム先に動作している必要があります。

この解決策では、ダイナミックバッファデータの複数のインスタンスが必要で、GPUがフレームnのデータを読み込んでいる間にCPUがフレームn+1のデータを書き込むことができます。

## メモリのオーバーヘッドとフレームレイテンシーを削減する

再利用可能なバッファのFIFOキューで、ダイナミックバッファデータの複数のインスタンスを管理することができます。

しかし、あまりに多くのバッファを割り当てることは、メモリのオーバーヘッドを増加させ、他のリソースへのメモリ割り当てを制限する可能性があります。

さらに、あまりに多くのバッファを割り当てると、CPUの作業がGPUの作業より進みすぎて、フレームレイテンシが増加します。

> **重要**  
> フレームごとに新しいバッファを作成しないようにする。リソースストレージを前もって割り当てることの概要については、[Persistent Objects](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/MTLBestPracticesGuide/PersistentObjects.html#//apple_ref/doc/uid/TP40016642-CH4-SW1)のベストプラクティスを参照してください。

## コマンドバッファのトランザクションのための時間を確保する

ダイナミックバッファーデータは、トランジェントコマンドバッファーにエンコードされバインドされます。

このコマンドバッファは、実行がコミットされた後、CPUからGPUに転送されるまでに一定の時間がかかります。

同様に、GPUがこのコマンドバッファの実行を完了したことをCPUに通知するのにも一定の時間がかかります。

このシーケンスは、1つのフレームについて、以下のように詳細に説明されています。

1. CPUはダイナミックデータバッファに書き込み、コマンドバッファにコマンドをエンコードする。

2. CPUは完了ハンドラをスケジュールし（`addCompletedHandler:`）、コマンドバッファをコミットし（`commit`）、コマンドバッファをGPUに転送する。

3. GPUはコマンドバッファを実行し、ダイナミックデータバッファから読み出す。

4. GPUが実行を完了し、コマンドバッファ完了ハンドラ（`MTLCommandBufferHandler`）を呼び出す。

このシーケンスは2つのダイナミックデータバッファで並列化できますが、どちらかのプロセッサがビジー状態のダイナミックデータバッファで待機している場合、コマンドバッファのトランザクションによってCPUが停止したりGPUが飢餓状態になったりすることがあります。

## トリプルバッファリングモデルを実装する
