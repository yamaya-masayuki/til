# Demystify SwiftUI

<https://developer.apple.com/wwdc21/10022>

今日は、SwiftUIを解明していきましょう。

さて、SwiftUIは宣言型のUIフレームワークであることは何度も聞いたことがあります。

つまり、アプリに求めるものを高いレベルで記述し、それを実現する方法をSwiftUIが正確に決定するということです。

さて、ほとんどの場合、これは素晴らしい働きをします。そしてそれは、SwiftUIが魔法のように感じられるときです。

しかし、SwiftUIが思いもよらないことをする瞬間は常にあります。

そのような時には、SwiftUIが舞台裏で何をしているのかをもう少し理解して、求めている結果を得るためのより良い直感を構築するのに役立ちます。

そこで今日の質問は、SwiftUIがあなたのコードを見るとき、何を見るのでしょうか？

答えは3つあります：アイデンティティ、ライフタイム、依存性です。

アイデンティティとは、SwiftUIがアプリの複数のアップデートに渡って、同じまたは異なる要素を認識する方法です。

ライフタイムは、SwiftUIが時間をかけてビューやデータの存在を追跡する方法です。

そして依存性は、SwiftUIがインターフェイスの更新が必要な時とその理由を理解する方法です。

これらの3つの概念は一緒になって、SwiftUIが何を、どのように、いつ変更する必要があるかを決定する方法を伝え、その結果、画面に表示されるダイナミックなユーザーインターフェイスを実現します。

今日は、この3つのコンセプトのそれぞれについて、より詳しく説明します。

まずアイデンティティから始めましょう。ここには私を助けてくれる数人の友人がいます。

このルビー・スパニエルは愛らしいですが、同時に深い哲学的な問いかけの対象でもあります。

この2匹は違う犬なのか？それとも、同じ犬の写真が2枚あるのでしょうか？実際のところ、それを言うことはできません。情報が足りないのだから。

しかし、この「同じか違うか」という問題は、私たちが「アイデンティティ」と呼ぶものの核心です。アイデンティティが重要なのは、犬にとってだけではありません。

また、SwiftUIがアプリを理解するための重要な側面でもあります。

その例を見てみましょう。

これは私が作った「Good Dog, Bad Dog」というアプリで、私の毛むくじゃらの友人が最高の行動をとったかどうかを記録するのに役立ちます。

使い方はとても簡単です。

画面のどこかをタップするだけで、良い状態と悪い状態を切り替えることができるのです。

では、「ID」が私のアプリとどのような関係があるのでしょうか？それは、先ほどの犬についての哲学的な問いかけとよく似ています。

これらのアイコンを見ると、まったく異なる2つの見解のように見えますか？それとも、場所や色が違うだけで、同じ景色なのでしょうか？この違いは、インターフェイスがある状態から別の状態へと移行する際の方法を変えるため、実際には非常に重要です。

例えば、これらのアイコンが、実際には異なるビューであるとします。

その場合、アイコンはフェードイン、フェードアウトのように独立して遷移する必要があります。

しかし、これらのアイコンが実際には同じビューであった場合はどうでしょうか？その場合は、遷移中にビューが画面上をスライドすることになります。なぜなら、同じビューがある場所から別の場所に移動するからです。

このように、異なる状態のビューを接続することは、SwiftUIがどのようにそれらの間を移行するかを理解するために重要です。

これが、ビューのアイデンティティの重要なコンセプトです。

同じアイデンティティを共有するビューは、同じ概念のUI要素の異なる状態を表します。

対照的に、異なるUI要素を表すビューは、常に異なるアイデンティティを持ちます。

講演の後半では、LucaとRajがビューアイデンティティがアプリのデータや更新サイクルに与える実際の影響について話します。

今のところは、SwiftUIで使用される2つの異なるタイプのアイデンティティに焦点を当てて、コードでアイデンティティがどのように表現されるかを見てみましょう。

まず、明示的なアイデンティティ：カスタムまたはデータ駆動型の識別子を使用します。

そして2つ目は、構造的なアイデンティティー：タイプとビュー階層の位置によってビューを区別することです。

さて、これらの概念を理解するために、私の友人をもう少し紹介しましょう。

同じように見える犬でも、見分けるのが難しいことを覚えておいてください。

では、どのような情報があれば、犬を見分けることができるのでしょうか？一つの方法は、単純に名前を聞くことです。

見た目が同じで名前も同じなら、同じ犬である可能性が高いと言えるでしょう。

でも、名前が違えば、違う犬であることが保証されます。

このように名前や識別子を割り当てることは、明示的なアイデンティティの一形態です。

明示的なアイデンティティーは強力で柔軟性がありますが、どこかで誰かがこれらの名前をすべて記録しておく必要があります。

明示的なアイデンティティーの1つの形式として、すでに慣れているかもしれませんが、UIKitとAppKit全体で使用されているポインタ・アイデンティティーがあります。

現在、SwiftUIはポインターアイデンティティを使用していませんが、それについて学ぶことは、SwiftUIがどのように、そしてなぜ異なって動作するのかをよりよく理解するのに役立ちます。

簡単に見てみましょう。

このような、UIKitやAppKitのビュー階層を考えてみましょう。

UIViewsとNSViewsはクラスなので、それぞれが自分のメモリ割り当てへのユニークなポインタを持っています。

このポインタは、明示的なアイデンティティの自然な源です。

私たちは、そのポインタを使って個々のビューを参照することができ、2つのビューが同じポインタを共有する場合、それらが本当に同じビューであることを保証することができます。

しかし、SwiftUIのビューは、クラスの代わりに構造体として一般的に表現される値の型であるため、SwiftUIはポインタを使用しません。

2019年に開催された"SwiftUI essentials"の講演では、SwiftUIがビューにクラスではなく値型(value type)を使用する理由について説明しましたので、詳しく知りたい方はその講演を見ることをお勧めします。

今のところ、知っておくべき重要なことは、値型は、SwiftUIがそのビューのための永続的なアイデンティティとして使用できる正規の参照を持たないということです。

代わりに、SwiftUIは他の形式の明示的なアイデンティティに依存します。

例えば、救助犬のリストを考えてみましょう。

ここで使用されているidパラメータは、明示的なアイデンティティの一形態です。

各救助犬のドッグタグIDは、リスト内の対応するビューを明示的に識別するために使用されます。

救助犬のコレクションが変更された場合、SwiftUIはこれらのIDを使用して何が正確に変更されたかを理解し、リスト内で正しいアニメーションを生成することができます。

このケースでは、SwiftUIは異なるセクション間を移動するビューを正しくアニメーションさせることもできました。

より高度な例を見てみましょう。

```swift
// Explicit Identity in SwiftUI

ScrollViewReader { proxy in
  ScrollView {
    HeaderView(rescueDog)
      .id(headerID)        

    Text(rescueDog.backstory)

    Button("Jump to Top") {
      withAnimation {
        proxy.scrollTo(headerID)
      }
    }
  }
}
```

ここでは、ScrollViewReaderを使って、下部のボタンを使ってビューの上部にジャンプしています。

`id(_:)`修飾子は、カスタム識別子を使用してビューを明示的に識別する方法を提供します。

そして、その識別子をスクロールビュープロキシの`scrollTo(_:)`メソッドに渡すことで、SwiftUIにその特定のビューに移動するように伝えることができます。

これが素晴らしいのは、すべてのビューを明示的に識別する必要がなく、ヘッダーテキストのようにコードの他の場所で参照する必要があるものだけを識別することができる点です。

それに比べて、ScrollViewReader、ScrollView、backstory Text、Bbuttonには、明示的な識別子は必要ありません。

しかし、アイデンティティが明示されていないからといって、これらのビューにアイデンティティがないわけではありません。

**全てのビューはアイデンティティを持っています、それが明示されていなくても。**

## 構造的アイデンティティ(Structural Identity)

ここで、構造的アイデンティティが登場します。

SwiftUIはビュー階層の構造を利用して、ビューの暗黙的なアイデンティティを生成するので、その必要はありません。

さて、私が何を言いたいのかを説明するために、もう少し仲間を連れてきましょう。

例えば、2匹の似たような犬がいて、名前は知らないけれど、それぞれを識別する必要があるとします。

その犬たちがとても良い犬で、じっとしていることができるとします。

動かないことが保証されていれば、「左の犬」「右の犬」のように、座っている場所だけで識別することができます。

被写体の相対的な配置を利用して、お互いを識別しているのです。これが構造的アイデンティティです。

```swift
var body: some View {
  if rescueDogs.isEmpty {
    AdoptionDirectory(selection: $rescueDogs)
  } else {
    DogList(rescueDogs)
  }
}
```

SwiftUIは、そのAPI全体で構造的アイデンティティを活用しており、典型的な例は、Viewコード内でif文やその他の条件付きロジックを使用する場合です。

条件文の構造は、各ビューを識別する明確な方法を与えてくれます。

最初のビューは、条件が真のときのみ表示され、2番目のビューは、条件が偽のときのみ表示されます。

つまり、見た目が似ていても、どちらのビューなのかを常に見分けることができるのです。

しかし、これはSwiftUIがこれらのビューがそれらの場所に留まり、決して場所を入れ替えないことを静的に保証できる場合にのみ機能します。

SwiftUIは、ビュー階層の型構造を見ることでこれを達成します。

```swift
some View =
  _ConditionalContent<
    AdoptionDirectory,
    
    DogList
  >
```

SwiftUIがビューを見るとき、その一般的な型を見ます。この場合、私たちのif文は`_ConditionalContent`ビューに変換され、trueとfalseのコンテンツの一般的な型となります。

この変換は、Swiftの結果ビルダーの一種であるViewBuilderによって行われます。

```swift
@ViewBuilder // implicit
var body: some View {
  if rescueDogs.isEmpty {
    AdoptionDirectory(selection: $rescueDogs)
  } else {
    DogList(rescueDogs)
  }
}
```

Viewプロトコルは、暗黙のうちにそのbodyプロパティをViewBuilderで包み、プロパティ内のロジックステートメントから単一のジェネリックビューを構築します。

bodyプロパティのいくつかのView戻り値型は、この静的な複合型を表すプレースホルダーで、コードを混乱させないように隠しています。

この一般的な型を使用することで、SwiftUIは真のビューが常にAdoptionDirectoryであることを保証し、偽のビューが常にDogListであることを保証し、舞台裏で暗黙の安定したアイデンティティを割り当てることを可能にします。

実はこれが、先ほどのGood Dog, Bad Dogアプリを理解するための鍵となります。

```swift
// 1番目のアプローチ
VStack {
  if dog.isGood {
    PawView(tint: .green)
    Spacer()
  } else {
    Spacer()
    PawView(tint: .red)
  }
}
```

上のコードでは、if文で条件分岐ごとに異なるビューを定義しています。

SwiftUIは、if文の各分岐が明確なアイデンティティを持つ異なるビューを表すことを理解しているので、これによりビューが移行します。

代わりに、レイアウトと色を変更する単一のPawViewを用意することもできます。

```swift
// 2番目のアプローチ
PawView(tint: dog.isGood ? .green : .red)
  .frame(
    maxHeight: .infinity,
    alignment: dog.isGood ? .top : .bottom)
```

別の状態に移行すると、ビューはスムーズに次の位置にスライドします。

これは、一貫したアイデンティティを持つ単一のビューを変更しているからです。

これらの戦略のどちらも機能しますが、SwiftUIは一般的に2番目のアプローチを推奨します。

デフォルトでは、アイデンティティを維持し、より流動的なトランジションを提供するようにします。

これはまた、ビューのライフタイムと状態を維持するのにも役立ちますが、これについては後ほどLucaが詳しく説明します。

構造的アイデンティティについて理解したところで、その邪悪な宿敵であるAnyViewについて説明する必要があります。

AnyViewの使用による影響を理解するために、AnyViewがビューの構造に与える影響を見てみましょう。

先ほど、AdoptionDirectoryとDogListを切り替えるために、このif文を書きました。

SwiftUIがこのコードを見ると、右のような一般的な型の構造が見えます。

今度は、AnyViewを多用した別の例を見てみましょう。

```swift
func view(for dog: Dog) -> some View {
  var dogView: AnyView
  if dog.breed == .bulldog {
    dogView = AnyView(BulldogView())
  } else if dog.breed == .pomeranian {
    dogView = AnyView(PomeranianView())
  } else if dog.breed == .borderCollie {
    dogView = AnyView(BorderCollieView())
    if sheepNeaby {
      dogView = AnyView(HStack {
        dogView
        SheepView()
      })
    }
  } else {
    dogView = AnyView(UnknownBreadView())
  }
  return dogView
}
```

これは、犬の品種を表すビューを取得するために書いたヘルパー関数です。

関数内の各条件分岐は異なる種類のビューを返すので、Swiftは関数全体に単一の戻り値の型を要求するので、私はそれらすべてをAnyViewでラップしました。

残念ながら、これはSwiftUIが私のコードの条件付き構造を見ることができないことを意味します。

代わりに、関数の戻り値型としてAnyViewを見ます。

これは、AnyViewが"type-erasing wrapper type"と呼ばれるもので、そのジェネリックシグネチャーからラップしているビューの型を隠しているからです。

しかし、おそらくもっと重要なことは、このコードは我々人間にとって本当に読みにくいということです。

このコードを単純化して、SwiftUIからその構造をもっと見えるようにできるか見てみましょう。

まず、この分岐では、近くに羊がいる場合、BorderCollieViewの横にSheepViewを条件付きで追加しているようです。

ビューの周りにHStackを条件付きで追加するのではなく、HStackの中にビューを条件付きで追加することで、これを単純化できます。

この変更により、各分岐から単一のビューを返していることがわかりやすくなったので、ローカルのdogView変数は必要ありません。

代わりに、各分岐の内部にあるreturn文で置き換えることができます。

先ほど見たように、通常のSwiftUIのViewコードは、異なるタイプのViewを返すif文を使用することができます。

しかし、コードからreturn文とAnyViewsを削除してみるだけで、いくつかのエラーや警告が表示されます。

これは、SwiftUIがヘルパー関数から単一のリターンタイプを要求するためです。

では、これらのエラーを回避するにはどうすればよいのでしょうか？ビューのbodyプロパティが特別であることを思い出してください。なぜなら、Viewプロトコルは暗黙のうちにViewBuilderでそれを包むからです。

これは、プロパティのロジックを単一の一般的なビュー構造に変換します。

さて、Swiftはデフォルトではビュービルダーであることをヘルパー関数に推論しませんが、手動でViewBuilder属性を自分で適用することで、それを選択することができます。

```swift
@ViewBuilder
func view(for dog: Dog) -> some View {
  var dogView: AnyView
  if dog.breed == .bulldog {
    BulldogView()
  } else if dog.breed == .pomeranian {
    PomeranianView()
  } else if dog.breed == .borderCollie {
    HStack {
      BorderCollieView()
      if sheepNeaby {
        SheepView()
      }
    }
  } else {
    UnknownBreadView()
  }
}
```

これにより、警告やエラーを出さずに、return文とAnyViewラッパーを削除することができます。

さて、私たちのコードはかなり良くなっています。すべてのAnyViewを取り除いたことで、以前よりも読みやすくなっています。

そして、結果の型シグネチャを見ると、条件付きコンテンツのツリーを持つ関数の条件付きロジックを正確に再現しており、SwiftUIにビューとそのコンポーネントのアイデンティティのより豊かな視点を提供しています。

```swift
// 型シグネチャ
some View =
  _ConditionalContent<
    _ConditionalContent<
      BulldogView,
      PomeranianView
    >,
    _ConditionalContent<
      HStack<
        TupleView<(
          BorderCollieView,
          SheepView?
        )>
      >,
      UnknownBreadView
    >
```

しかし、もう一つ小さな改善点があります。

私たちの関数のトップレベルは、犬の品種の異なるケースに対してマッチングしているだけです。

これは、ビュービルダーでもサポートされているswitch文の優れた使用例のようです。

ビュービルダーでもサポートされているswitch文を使えば、ビューのさまざまなケースを簡単に理解することができます。

また、switch文は単なる条件文の構文解析であるため、結果として右図のビューの型シグネチャは全く変わりません。

```swift
@ViewBuilder
func view(for dog: Dog) -> some View {
  var dogView: AnyView
  switch dog.breed {
  case .bulldog:
    BulldogView()
  case .pomeranian:
    PomeranianView()
  case .borderCollie:
    HStack {
      BorderCollieView()
      if sheepNeaby {
        SheepView()
      }
    }
  default:
    UnknownBreadView()
  }
}
```

前置きが長くなりましたが、AnyViewがコードから型情報を消去することを示し、ビュービルダーを利用して不要なAnyViewを取り除く方法を説明しました。

一般的には、可能な限りAnyViewを使用しないことをお勧めします。

あまりにも多くのAnyViewがあると、コードが読みにくく、理解しにくくなります。

if/elseやswitchのような伝統的な制御フロー文は、ビューのさまざまな可能な状態をより簡単に見ることができます。

また、AnyViewは静的な型の情報をコンパイラから隠すため、コードに表示される診断エラーや警告を防ぐことができます。

最後に、必要のないときにAnyViewを使用すると、パフォーマンスが悪くなることを覚えておいてください。

可能であれば、コードにAnyViewを渡すのではなく、静的な型情報を保持するためにジェネリックを使用してください。

以上で、SwiftUIにおけるビューアイデンティティの基本的な種類の紹介を終えました。

## NOTE: AnyView

- コードの理解が困難になる
- コンパイル時の診断機能が少ない
- 必要のないときのパフォーマンスが低下する

明示的なアイデンティティでは、ビューのアイデンティティをデータに結び付けたり、特定のビューを参照するためにカスタムの識別子を提供したりすることができます。

また、構造的アイデンティティでは、SwiftUIがそのタイプとビュー階層内の位置に基づいてビューを識別する方法を学びました。

それでは、ビューのアイデンティティがそのライフタイムや状態にどのように関連するかを説明するために、ルカに話を引き継ぎます。

## Luca Bernardi: ありがとう、マット

さて、SwiftUIがビューを識別する方法を理解したところで、アイデンティティがビューやデータのライフタイムにどのように関係するかを探ってみましょう。

これは、SwiftUIがどのように動作するかをよりよく理解するのに役立ちます。

これを説明するために、私も友人を連れてくるつもりです。

これはテーセウスです。
(テーセウス = 猫の名前)

彼も愛らしいでしょう？誰かがもっと愛らしいと言うでしょうが、余談です。

私たちは、自分の好きなペットに名前をつけたら、その状態が変わっても、一日中動いていても、いつも同じ愛らしい猫だと思うのはとても直感的なことです。

私たちが彼を見ると、彼は眠そうにしているかもしれませんし、次の瞬間には、ちゃんとした猫であるがゆえに私の存在を迷惑がっているかもしれません。

これが、アイデンティティとライフタイムを結びつけることの本質です。

アイデンティティによって、時間の経過とともに異なる価値観を持つ安定した要素を定義することができます。

言い換えれば、時間的な連続性を導入することができるのです。

これがSwiftUIにどう当てはまるのか、疑問に思うかもしれません。そこで、Mattが作業していたアプリを猫用に戻してみましょう。

テーセウスが異なる瞬間に異なる状態になることがあるように、私たちのビューもまた、その生涯を通じて異なる状態にあります。

それぞれの状態は、ビューにとって異なる価値を持っています。

アイデンティティは、これらの異なる値を1つのエンティティ（ビュー）として時間をかけて結びつけます。

これを明らかにするために、いくつかのコードを見てみましょう。

```swift
struct PurrDecibelView: View {
  var intensity: Double

  var body: some View {
    //...
  }
}
```

```swift
var body: some View {
  PurrDecibelView(intensity: 25)
}
```

ここでは、鳴き声の強さを表示するシンプルなビューを用意しました。

ネタバレになりますが テセウスはかなりうるさいですね。

bodyの評価を通じて、SwiftUIはこのビューに新しい値を作成します。この場合、強度の値は25です。

テセウスはお腹が空いてきて、もっと注目されたいと思っています。

bodyはより高い強度で再び呼び出され、ビューの新しい値が作成されます。

これらは、同じビュー定義から作成された2つの異なる値です。

SwiftUIは、比較を実行し、ビューが変更されたかどうかを知るために、値のコピーを維持します。

しかし、その後、値は破棄されます。

ここで理解することが重要なのは、ビューの値はビューのアイデンティティとは異なるということです。

`ビューの値≠ビューのアイデンティティ`

ビューの値は一時的なものであり、その寿命に頼るべきではありません。

しかし、あなたがコントロールできるのは、そのアイデンティティです。

ビューが最初に作成され、それが表示されるとき、SwiftUIは前に議論された技術の組み合わせを使用して、それにアイデンティティを割り当てます。

時間の経過とともに、更新によって駆動され、ビューのための新しい値が作成されます。

しかし、SwiftUIの視点では、これらは同じビューを表します。

ビューのアイデンティティが変更されるか、ビューが削除されると、そのライフタイムは終了します。

私たちがビューの寿命について話すときはいつでも、そのビューに関連付けられたアイデンティティの期間を参照しています。

`あるビューの寿命はそのアイデンティティの期間である`

ビューのアイデンティティとそのライフタイムを結びつけることができることは、SwiftUIがどのように状態を持続させるかを理解する上で基本となります。

そこで、StateとStateObjectを図に入れてみましょう。

```swift
struct CatRecorder: View {
  @State var title = ""

  @StateObject var mic = Microphone()

  var body: some View {
    VStack {
      TextField("Title:", text: $title)
      MicView(mic)
    }
  }
}
```

SwiftUIがビューを見て、StateやStateObjectを見たとき、それはビューのライフタイムを通してそのデータの一部を永続化する必要があることを知っています。

言い換えれば、StateとStateObjectは、ビューのアイデンティティに関連する永続的なストレージです。

ビューのアイデンティティの始まりで、最初に作成されるとき、SwiftUIはStateとStateObjectのために、それらの初期値を使用してメモリ内のストレージを割り当てます。

ここでは、タイトルの状態に焦点を当てています。

ビューの寿命を通して、SwiftUIは、それが変異し、ビューのボディが再評価されるように、このストレージを永続化します。

アイデンティティの変更が状態の永続化にどのように影響するか、具体的な例を見てみましょう。

これは、同じビューが2つの別々の分岐にあるという興味深い例です。

```swift
var body: some View {
  if dayTime {

    CatRecorder()

  } else {

    CatRecorder().
      nightTimeStyle()

  }
}
```

前に覚えていると思いますが、構造的アイデンティティのために、2つのビューは異なるアイデンティティを持っていると考えられます。

Matt氏は、これがアニメーションにどのような影響を与えるかを説明しましたが、これは状態の永続性にも大きな影響を与えます。

これを実際に見てみましょう。

最初にbodyを評価し、trueの分岐に入ったとき、SwiftUIは初期値で状態のための永続的なストレージを割り当てます。

このビューのライフタイムを通して、SwiftUIは様々なアクションによって変異される状態を永続化します。

しかし、dayTimeの値が変わり、偽の分岐に入った場合はどうなるでしょうか？SwiftUIは、これが明確なアイデンティティを持つ別のビューであることを知っています。

状態の初期値から始まって、偽のビューのための新しいストレージが作成され、真のビューのためのストレージはその直後に解放されます。

しかし、真の分岐に戻った場合はどうでしょうか？さて、これはまた新しいビューなので、SwiftUIは状態の初期値から始めて新しいストレージを作成します。

ここでのポイントは、アイデンティティが変わるたびに、ステートが置き換えられるということです。

ここでちょっと立ち止まって、この重要なポイントを理解していただきたいのですが、ステートの永続性はビューの寿命に結びついています。

`ステートの寿命 = ビューの寿命`

これは非常に強力な概念です。なぜなら、ビューの本質であるステートを明確に分離し、それをアイデンティティに結びつけることができるからです。

他のすべてはそこから派生します。

SwiftUIは、データのアイデンティティをビューの明示的なアイデンティティのフォームとして使用するデータ駆動型の構造のセットを持っているので、あなたのデータはとても重要です。

この典型的な例がForEachです。

それでは、ForEachを初期化するさまざまな方法をすべて見てみましょう。

これは、このタイプをよりよく理解するための助けとなります。

ForEach の最も単純な形式は、定数の範囲を取るものです。

```swift
ForEach(0..<5) { offce in
  Text("🐑 \(offset)")
}
```

これは非常に便利な初期化方法で、特に新しいUIのプロトタイピングを始めようとしているときに便利です。

SwiftUIは、ビュービルダによって生成されたビューを識別するために、この範囲のオフセットを使用します。

一定の範囲を必要とすることで、ビューの存続期間中、アイデンティティが安定していることを保証します。

実際、このイニシャライザを動的な範囲で使用することはエラーとなります。

また、今年の新機能として、一定でない範囲を指定した場合には警告が表示されます。

もっと面白くするために、データの動的なコレクションを導入してみましょう。

このイニシャライザは、コレクションと、識別子となるプロパティへのキーパスを受け取ります。

```swift
ForEach(rescueCats: id: \.tagID) { rescueCat in
  ProfileView(rescueCat)
}
```

SwiftUIは、コレクションの要素から生成されたすべてのビューにアイデンティティを割り当てるためにその値を使用するので、このプロパティはハッシュ化可能でなければなりません。

後で、Rajは、安定したアイデンティティを選択することが、アプリのパフォーマンスと正しさにどのように影響するか、いくつかの例を示すつもりです。

データに安定したアイデンティティを提供するというこのアイデアは、標準ライブラリがこの機能を記述するためにIdentifiableプロトコルを定義するほど重要です。

そして、SwiftUIはこのプロトコルを最大限に活用し、キーパスを省略して、データとビューに関連するアイデンティティを定義するためにプロトコルの要件によって提供される識別子を使用することができます。

私がSwiftについて本当に好きなことは、私たちが解決している問題の制約を正確に記述するために、その型システムを利用できることです。

ですから、ここで使用しているイニシャライザの定義を見てみましょう。

```swift
extension ForEach
  where Content: View, Data.Element: Identifiable, ID == Data.Element.ID
{
  public init(
    _ data: Data,
    @ViewBuilder content: @escaping (Data.Element) -> Content
  )
}
```

この短い定義の中には興味深いものがたくさんありますので、それを紐解いてみましょう。

ForEachには2つの主な要素が必要です。コレクション（ここでは一般的な引数Dataで示される）と、コレクションの各要素からビューを生成する方法です。

このイニシャライザの形状から、ForEachがデータのコレクションとビューのコレクションの関係を定義していることが直感的にわかると思います。

しかし実際には、ここで最も興味深いのは、コレクションの要素をIdentifiableであるように制約していることです。

繰り返しになりますが、Identifiableプロトコルの目的は、型がアイデンティティの安定した概念を提供できるようにすることで、SwiftUIがその寿命を通してデータを追跡できるようにすることです。

実際に、これは以前に説明したアイデンティティとライフタイムの概念に非常に似ています。

識別可能な型とビュービルダーを取るSwiftUIのビューは、データ駆動型のコンポーネントです。

これらのビューは、あなたが提供したデータのアイデンティティを使用して、それに関連付けられたビューのライフタイムをスコープします。

良い識別子を選択することは、ビューとデータの寿命をコントロールする機会となります。

それでは、このセクションで説明してきたことをまとめてみましょう。

ビューの値は一過性のものであり、その寿命に頼るべきではありません。

しかし、それらのアイデンティティはそうではなく、時間的な継続性を与えるものです。

あなたはビューのアイデンティティをコントロールすることができ、アイデンティティを使って状態の寿命を明確にスコープすることができます。

そして最後に、SwiftUIはデータドリブンなコンポーネントのためのIdentifiableプロトコルを最大限に活用しますので、データのために安定した識別子を選択することが重要です。

## 寿命

- ビューの値は短命である
- ビューの寿命はそのアイデンティティの期間である
- 状態の永続化は寿命に紐付けられる
- データのために安定したアイデンティティを提供しなさい

そして、伝統を引き継いで、私はラジにそれを渡します。

ラージ？Raj Ramamurthyです。ルカさん、ありがとうございます。これまでに、アイデンティティとは何か、そしてそれがビューの寿命とどのように結びつくのかを説明してきました。

次は、SwiftUIがどのようにUIを更新するのかに踏み込んでみたいと思います。

その目的は、SwiftUIのコードをどのように構成するか、より良いメンタルモデルを与えることです。

また、最後にすべてを概説するいくつかの例を示すつもりです。

依存関係の議論を始めるために、ビューを見てみましょう。

```swift
struct DogView: View {
  @Binding var dog: Dog
  var treat: Treat

  var body: some View {
    Button {
      dog.reward(treat)
    } label: {
      PawView()
    }
  }
}
```

ここでは、シンプルなビューを紹介します。

これは、犬におやつを与えるボタンを表示しています。

申し訳ありませんが、Lucaさん、私はどちらかというと犬の方が好きです。

ビューの構造に注目してみましょう。

まず、上部を見てみましょう。

2つのプロパティがあります。1つは犬、もう1つはおやつです。

これらのプロパティは、ビューの依存関係です。

依存関係とは、ビューへの入力に過ぎません。

依存関係が変化すると、ビューは新しいボディを生成することが求められます。

ボディは、ビューの階層を構築する場所です。

このビューの階層に入ると、アクションを持つボタンがあります。

アクションは、ビューの依存関係の変更を引き起こすものです。

コードを図に置き換えてみましょう。

これは、DogViewの図です。

私たちがボタンをタップすると、犬に報酬を与えるアクションが実行されます。

犬はあっという間におやつを食べてしまいました。

その結果、犬に変化が起こりました。

依存関係が変わったので、DogViewは新しいボディを生成します。

SwiftUIにおけるデータフローの一般的な概念について詳しく知りたい方は、WWDC 2020の"Data essentials in SwiftUI"をご覧ください。

次に、この図を少し簡略化してみましょう。

ビューの階層に注目してみると、ビューが木のような構造になっていることに気がつきます。

また、DogとTreatの依存関係を一番上に戻すと、やはりツリーのように見えます。

しかし、DogViewは依存関係を持つ唯一のビューではありません。

SwiftUIでは、各ビューが独自の依存関係のセットを持つことができます。

ここまでは、まだツリーのように見えます。

しかし、注意してほしいのは、同じ状態や他のデータに依存する複数のビューが存在することです。

例えば、子孫の一つが犬にも依存しているかもしれません。

また、他の依存関係についても同じことが言えます。

というわけで、最初はツリーからスタートしましたが、この構造は今ではゆるやかにしかツリーに似ていません。

実際、線が重ならないように並べ直すと、このような構造になり、これは木ではなく、実はグラフであることがわかります。

実際、私たちはこの構造を「依存関係グラフ」と呼んでいます。

この構造が重要なのは、SwiftUIが新しいボディを必要とするビューのみを効率的に更新することができるからです。

例えば、一番下にある依存関係を見てみましょう。

この依存関係を調べてみると、2つの依存するビューがあります。

このグラフの秘密は、依存関係が変更された場合、それらのビューだけが無効になることです。

SwiftUIは各ビューのボディを呼び出し、各ビューの新しいボディの値を生成します。

SwiftUIは、無効になった各ビューのボディの値をインスタンス化します。

その結果、より多くの依存関係が変更されるかもしれませんが、必ずしもそうではありません ビューは値の型なので、SwiftUIは効率的にそれらを比較して、ビューの正しいサブセットのみを更新することができます。

これは、先ほどLucaが話したことを別の角度から見たものです。

ビューの値は短命です。

構造体の値は比較のために使われるだけで、ビュー自体の寿命はもっと長いのです。

これが、中央のビューのために新しいボディを生成しないで済む方法です。

アイデンティティは、依存関係グラフのバックボーンです。

マットが言ったように、すべてのビューは、明示的に指定されているか、構造的に指定されているかに関わらず、アイデンティティを持っています。

そのアイデンティティは、SwiftUIが正しいビューに変更をルーティングし、効率的にUIを更新する方法です。

## 依存関係グラフ

- SwiftUIビューの基本的な表現である
- アイデンティティはグラフの背骨である
- UIを効率よく更新する
- 値の比較はボディの生成を減らす

依存関係には様々な種類があります。

## 依存関係の種類

構造体のプロパティ🦴

- `@Binding`
- `@Environment`
- `@State`
- `@StateObject`
- `@ObservedObject`
- `@EnvironmentObject`

以前、treatプロパティとdogバインディングでいくつかの例を見ましたが、環境、状態、または観察可能なオブジェクトプロパティのラッパーのいずれかを使用して依存関係を形成することもできます。

次に、ビューでのアイデンティティの使用を改善する方法についてお話ししたいと思います。

これにより、SwiftUIがあなたのコードをよりよく理解できるようになります。

Lucaが言ったように、ビューの寿命はそのアイデンティティの期間であり、識別子の安定性が重要であることを意味します。

安定していない識別子は、ビューの寿命を短くしてしまいます。

また、安定した識別子を持つことは、SwiftUIが継続的にビュー用のストレージを作成したり、グラフの更新に追われたりする必要がないため、パフォーマンスの向上にもつながります。

先に見たように、SwiftUIは永続化されたストレージを管理するために寿命を使用するので、安定した識別子は状態の損失を避けるためにも重要です。

識別子の安定性の重要性を説明するために、コードの例を見てみましょう。

この例では、私の好きなペットのリストを持っています。

pet構造体に識別子を設定しています。

```swift
enum Animal { case dog, cat }

struct Pet: Identifiable {
  var name: String
  var kind: Animal
  var id: UUID { UUID() } // ← 不安定
}

struct FavoritePets: View {
  var pets: [Pet]
  var body: some View {
    List {
      ForEach(pets) {
        PetView($0)
      }
    }
  }
}
```

しかし、実はバグがあって、新しいペットを手に入れるたびに、画面上のすべてが点滅してしまうのです。ちょっと立ち止まって、このコードを見てみましょう。

どこにバグがあるかわかりますか？バグはここ、Identifiable conformanceにあります。

テストに合格しなくても、このセクションにはおやつはありませんのでご安心ください。

問題は、この識別子が安定していないことで、データが変更されるたびに新しい識別子を得ることになります。

代わりに，petsの配列のインデックスを使ったらどうでしょうか？

```swift
struct FavoritePets: View {
  var pets: [Pet]
  var body: some View {
    List {
      ForEach(pets.indecies, id: \.self) { // ← 不安定
        PetView(pets[$0])
      }
    }
  }
}
```

残念ながら、これにも同様の問題があります。

添字を使うことで、ビューはコレクション内のそれぞれのペットの位置で識別されるようになります。

お気に入りのペットができたら、他のすべてのペットのIDが変わってしまい、悪いバグが発生する可能性があります。

この例では，ボタンを押すとインデックス0に新しい要素が挿入されますが，最後のインデックスが新しいものであるため，最初ではなく最後に挿入されることになります。

これは、計算されたランダムな識別子のように、インデックスは安定した形のアイデンティティではないからです。

この例では、データベースから取得したものや、ペットの安定した特性から得られたものなど、安定した識別子を使用する必要があります。

```swift
struct FavoritePets: View {
  var pets: [Pet]
  var body: some View {
    List {
      ForEach(pets, id: \.databaseID) { // ← 安定
        PetView($0)
      }
    }
  }
}
```

永続的な識別子であれば何でも構いません。

これで、アニメーションがきれいになりましたね。しかし、優れた識別子に必要な特性は安定性だけではありません。

優れた識別子のもう一つの特性は一意性です。

それぞれの識別子は、単一のビューに対応していなければなりません。

これにより、アニメーションが美しく、パフォーマンスがスムーズで、階層の依存関係が最も効率的な形で反映されるようになります。

## 識別子の一意性

- アニメーションを向上させる
- 性能の助ける
- 依存関係を正しく反映する

別の例を見てみましょう。

```swift
struct TreatJar: View {
  var treats: [Treat]

  var body: some View {
    ScrollView {
      LazyGrid(...) {
        ForEach(treats, id: \.name) { // ← 同一性がない
          TreatCell($0)
        }
      }
    }
  }
}
```

この例では、私のペットのお気に入りのおやつをすべて集めたビューを作っています。

それぞれのおやつには、名前、絵文字、そして賞味期限があります。

それぞれのおやつを名前で識別することにしました。

この時点で、あなたは想像できると思いますが、ここにもバグが発生しています。

同じ種類のおやつを複数個持っているとどうなるか？私は犬用のビスケットをまとめて買うのが好きです。

瓶に入れても、出てこないことがあります。問題は、おやつの名前が、そのおやつのユニークな識別子ではないということです。

代わりに、シリアル番号やその他のユニークなIDをおやつごとに使用することができます。

そうすることで、正しいデータがすべて表示されるようになります。

また、より良いアニメーションとより良いパフォーマンスが確保されます。

SwiftUIが識別子を必要とするとき、それはあなたの助けを必要とします! 特に計算されたプロパティで、ランダムな識別子を使用するときは注意してください。

一般的には、すべての識別子が安定していることを望みます。

識別子は時間の経過とともに変化してはいけません。新しい識別子は、新しい寿命を持つ新しいアイテムを表します。

そして最後に、識別子は一意でなければなりません。

複数のビューが一つの識別子を共有することはできません。

SwiftUIは、アプリをスムーズにバグなく動作させるために、これらのプロパティに依存しています。

## 明示的アイデンティティ

- SwiftUIはあなたの助けが必要
- ランダムな識別子には注意が必要
- 安定している識別子を使う
- 一意性の確保するには、アイテム毎に識別子を用意する

さて、明示的なアイデンティティについて話した後は、構造的アイデンティティに移りたいと思います。

この例では、先ほどのおやつの瓶に取り組んでいます。

```swift
ForEach(treats, id: \.serialNumber) { treat in
  TreatCell(treat)
    .modifier(ExpirationModifier(date: treat.expiryDate))
}

struct ExpirationModifier: ViewModifier {
  var date: Date
  func body(cojntent: Content) -> some View {
    if date < .now {
      content.opacity(0.3)
    } else {
      content
    }
  }
}
```

私は責任あるペット愛好家として、自分のペットには賞味期限の切れていない最高の食品しか与えません。

おやつが腐ってしまったことを見分けるために、新しい修飾子を追加しました。この修飾子は、おやつが期限切れになったときに、オプションでおやつのセルを暗くします。

淡い色になったセルをハイライトしています。

それでは、モディファイアを見てみましょう。

モディファイアでは、日付を指定し、現在の日付と比較して、ビューを暗くするタイミングを知ることができます。

一見するとこれでいいように見えますが、ここには微妙な問題があります。

条件が変わり、おやつが期限切れになった場合、ここには分岐があるため、結局新しいIDが必要になります。

マットが説明したように、分岐は構造的アイデンティティの一形態です。

つまり、コンテンツのコピーが1つではなく、任意に変更できる2つのコピーがあるということです。

ここでの分岐はモディファイアの中にあることに注意してください。

わかりやすくするために、モディファイアとその使用サイトを同じスライドに載せましたが、あなたのプロジェクトでは、気づかないうちにファイル間でこのような分岐があるかもしれませんね。もちろん、ここで説明したことはすべてビューとビューモディファイアにも当てはまります。

では、どうすればこのような事態を避けることができるのでしょうか？ひとつの方法は、このように分岐を折りたたんで、不透明度モディファイアの中に条件を移すことです。

この分岐を削除することで、このビューは単一のアイデンティティを持つものとして正しく記述されます。

```swift
ForEach(treats, id: \.serialNumber) { treat in
  TreatCell(treat)
    .modifier(ExpirationModifier(date: treat.expiryDate))
}

struct ExpirationModifier: ViewModifier {
  var date: Date
  func body(cojntent: Content) -> some View {
    content.opacity(date < .now ? 0.3 : 1.0)
  }
}
```

さらに、条件を不透明度修飾子の中に移動させることで、依存するコードをタイトにスコープしたため、パフォーマンスが向上します。

というのも、依存するコードをしっかりとスコープしたからです。

このトリックは、条件が真の場合、不透明度を1にすることで、次のようになります。

不透明度が1の場合は何の効果もありません。

このようなモディファイアは、レンダリング結果に影響を与えないので、「不活性モディファイア」と呼んでいます。

SwiftUIのモディファイアは安価なので、このパターンには本質的なコストはほとんどありません。

結果として視覚的な効果がないので、フレームワークは効率的にモディファイアを削除し、そのコストをさらに減らすことができます。

分岐は素晴らしく、理由があってSwiftUIに存在しています。

しかし、不必要に使用されると、パフォーマンスの低下、驚くべきアニメーション、そしてLucaが示したように、ステートの喪失さえも引き起こす可能性があります。

分岐を導入する際には、ちょっと立ち止まって、複数のビューを表現しているのか、同じビューの2つの状態を表現しているのかを考えてみてください。

先ほど見たように、単一のビューを識別するためには、分岐の代わりに不活性修飾子を使用した方がうまくいくことがよくあります。

ここでは、不活性修飾子の例をいくつか紹介します。

私が特に気に入っているのは、環境に条件付きで書き込むための`transformEnvironment`です。

## 構造的アイデンティティ

- 不要な分岐をなくす
- より狭い範囲に依存するコード
- 好ましい挿入修飾子
    - `opacity(1)`
    - `padding(0)`
    - `transformEnvironment(...) {}`

## まとめ

以上をまとめると、今日はアイデンティティが素晴らしいパフォーマンスの秘訣の一つであることを示しました。

明示的アイデンティティと構造的アイデンティティについて説明し、アプリを改善するためにそれぞれをどのように利用できるかを説明しました。

アイデンティティからは、関連するストレージや遷移などを制御するビューのライフタイムを導き出すことができます。

また、SwiftUIはアイデンティティとライフタイムを使用して依存関係を形成し、それがグラフで表現されてUIを効率的に更新できることを説明しました。

SwiftUIを解明するとともに、アプリのバグを回避し、パフォーマンスを向上させるためのヒントやコツをお伝えしました。

そして、これらのトリックを学んだ今、あなたのコードを見て回り、それらが役に立つかどうかを確認してください。
