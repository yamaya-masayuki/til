# Secure login with iCloud Keychain verification codes

<https://developer.apple.com/wwdc21/10105>

アプリやWebサイトでデバイス上の検証コードをサポートし、より安全なサインイン体験を実現する。

iCloud Keychainパスワードマネージャーの最新のアップデートを紹介する。

参考: [Appleの発表したPasskeys in iCloud KeychainはWebAuthnをどう変えるのか - r-weblife](https://ritou.hatenablog.com/entry/2021/06/15/060000)

## パスワード

パスワードはどこにでもあり、人々はその使用方法を理解しています。しかし、パスワードを正しく使うのは難しいことがわかっています。実際には、パスワードを正しく使うよりも、誤用するほうが簡単です。複数のWebサイトでパスワードを使いまわしたり、推測しやすいパスワードを選んだりすることはよくあります。

また、攻撃者が誰かにパスワードを教えてもらうのも簡単です。

そこでサービス側は、ユーザーのアカウントにセキュリティを持たせつつ、簡単にログインできるようにするにはどうすればよいか、というジレンマに直面しています。多くのサービスでは、ログインフローにステップを設けています。多くのサービスでは、ログインフローにステップを設け、本人確認のための情報を追加しています。このようなステップを追加することで、パスワードを持った攻撃者が、その人のアカウントにアクセスできる可能性を減らすことができます。また、その人が同じパスワードを使用した他のアカウントに、攻撃者が自動的にアクセスできなくなることもあります。

検証コードは、一般的な追加手順です。サービスは、ユーザー名とパスワードを入力した後に、これらのコードを要求します。これらのコードは、SMS、電子メール、またはプッシュ通知で配信されるか、あるいは、その人の携帯電話上の認証アプリまたはハードウェアキーフォブ(Key fob)で生成されます。

## 検証コード

このコードの最大の特徴は、使い捨てであるということです。暗記したり保存したりすることを目的としていないため、パスワードのように再利用される心配はありません。とはいえ、検証コードは人間が入力する必要があるため、パスワードと同様にフィッシングの危険性があります。

確認コードの配信方法でもっとも一般的なのはSMSである。携帯電話を持っている人なら、ほとんどの人がSMSを受信することができルシ、人々はSMSの送受信を理解しています。

AutoFillは、これらのコードをより簡単に使用できるようにした。ワンタップでコードを入力することができる。

しかし、SMSで配信される検証コードには、まだ問題があります。

## SMS検証コード

検証コードは安全ではない。検証コードは、通信事業者のネットワーク上での盗聴や、攻撃者が他人に宛てたメッセージを受け取ることができるSIMスワッピング攻撃に対して脆弱である。

テキストメッセージはエラーなく届くのが当たり前だと思われがちだが、そのためにはネットワークへのアクセスが必要。飛行機に乗っていたり、電波の届かないところにいると、メッセージが届くまでに時間がかかったり、まったく届かなかったりする。

また、SMSメッセージは送信にも受信にもコストがかかります。何百万通ものメッセージを送信するとなると、かなりの額になります。

## 時間ベース検証コード

検証コードを作成する別の方法として、デバイス上のコードジェネレータがある。このアルゴリズムは[RFC 6238](https://tex2e.github.io/rfc-translater/html/rfc6328.html)で定義されており、"Time-Based One-Time Passwords (TOTP)"と呼ばれている。このアルゴリズムは、秘密鍵と時刻を入力とし、これらの情報に基づいて短い数字のコードを生成する。一般的には、認証アプリやハードウェアデバイスがコードを生成する。サービスとの通信は必要なく、すべてはデバイス上で行われる。

これは、セキュリティやUXの面で大きなメリットがある。コードの有効期限は、通常30秒ほどの短い時間である。また、誰もがSMSメッセージを送受信する必要がないため、サービスと顧客の両方にとってコスト削減につながる。

TOTPの課題は、設定がやや複雑になる傾向があること。

サービスは、顧客のデバイスがコードの生成を開始できるように、他のパラメータと一緒に秘密鍵を顧客と共有する必要がある。典型的な設定方法は、ある端末にQRコードを表示し、別の端末に認証アプリをダウンロードして、そのアプリでQRコードを読み取るというもの。これは面倒だし、人に説明するのも難しい。

デバイス上でコードを生成することは、誰にとってもより良い体験となりますが、セットアップにはいくつかの厄介な問題がある。iCloud Keychainの新機能は、そのような問題点を慎重に検討したうえで開発された。

## iCloud keychain検証コード

iOS 15とmacOS Montereyの新機能として、iCloud Keychainパスワードマネージャーに時間ベースの検証コード生成機能を搭載した。

このデバイスや別のデバイスで使用するコードを調べたり、コピーしたりできる。

AutoFillはこの機能をさらに充実させている。SMSで送られてくるコードと同じように、AutoFillは生成された検証コードをワンタップで入力できる。コードをすぐ利用できるので、お客さまはより合理的で信頼性の高いサインイン体験を得ることができ、SMSメッセージの送信コストを削減することができる。

この機能の特徴は、新しい検証コードを簡単に設定できること。TOTPの設定ページへのリンクやボタンを追加すると、iOS 15やmacOS Montereyを使っている人が、同じデバイス上で数回タップするだけで、新しい検証コードを設定することができます。本当に、とても簡単にできる。

検証コードはユーザーの全デバイスで同期され、iCloud Keychainによって安全にバックアップされる。そのため、Macでアカウントにサインインする際に、わざわざiPhoneを取り出して検証コードを入力する必要はない。

これはアカウントの復元にも最適である。検証コードがiCloudに安全にバックアップされていれば、デバイスを紛失してもアカウントへのアクセスを失うことはない。ちなみに、iCloud Keychainにあるものはすべてエンドツーエンドで暗号化されているので、アカウントの所有者以外の誰も（Appleも他の人も）アクセスできない。

お客さまに最高の体験をしていただくために、簡単にできることがある。セットアップのフローには2つ、ログインのフローには1つある。

数回のタップで新しい検証コードを設定できることは大きな意味がある。何億人ものiPhoneユーザーが、iOS 15にアップデートした途端にこれができるようになる。設定画面にリンクやボタンを追加することで、ユーザーのデバイスに認証コードを設定するのが非常に簡単になる。

TOTPコードでのログインをサポートするインフラをすでにお持ちの方は、`otpauth:` URLを知っているであろう。

```text
otpauth://totp/Shiny:eryn@example.com?secret=NBSWY3DP&digits=6&period=30&issuer=example.com
```

このURLには、BASE32エンコードされた秘密鍵、各コードの桁数、各コードの有効期間、ドメイン名に設定すべき発行者フィールドなど、コードジェネレータの設定に必要なすべての情報が含まれている。これは、TOTPのセットアッププロセスで一般的に使用されるQRコードにエンコードするのと同じURL。URLの前に`apple-`を付けることで、iCloud Keychainパスワードマネージャーに直接リンクできる。

この `apple otpauth:` URLを、あなたのWebページのアンカータグに入れることができる。

また、アプリでは2つの選択肢があります。textViewの`attributedString`プロパティに割り当てた`NSAttributedString`に `link`属性を追加してリンクを作成するか、ウィンドウシーンのopen APIを使ってボタンタップに反応してURLを開くことができる。システムが `apple otpauth: URL`を開くどうかは、可用性チェックで確認できる。旧バージョンのiOSでは、セットアップボタンを非表示にし、セットアップURLを削除する必要がある。

セットアップ中にできる2つ目のことは、他のTOTPアプリでスキャンされることを目的としたQRコードに、JPG、PNG、GIFなどのラスター画像を使用すること。Safariは、デバイス上の画像解析を使ってQRコードを検出し、そのコードに含まれる情報をデコードします。QRコードに`otpauth: URL`が含まれているとSafariが判断した場合は、QRコード画像のコンテキストメニューでコードジェネレータの設定を提案する。

ログインのフローについては、次のようにテキストフィールドに注釈することができる。

AutoFillがユーザー名、パスワード、および検証コードを入力する場所を正確に知っていることを確実にするために、コンテンツタイプでそれらのテキストフィールドを注釈します。SwiftUIでは`textContentType`ビューモディファイアで、UIKitでは`UITextFields`の`textContentType`プロパティで、AppKitアプリでは`NSTextFields`の`contentType`プロパティでこれを行なう。

Webでは、`input`要素の`autocomplete`属性を"one-time-code"に設定する。

## 認証の未来

認証メカニズムはスペクトル上に存在し、その強度とセキュリティは段階的に高まっている。パスワードは業界の伝統的なベースラインであり、サービスがパスワードベースのログイン・フローを強化する方法は数多い。もっとも一般的なものは、SMSで配信されるパスワード＋コードと、TOTPで生成されるパスワード＋コードの2つです。

サービスが行える追加的な決定は、認証のプロセス全体を別のサービスに委ねるフェデレート・サインイン・プロバイダを使用するかどうかである。フェデレート認証は、従来の認証方法と同じメカニズムに基づくが、ユーザーが管理するパスワードの数は少なくなる。"Sign in with Apple"のように、堅牢で安全なインフラ上に実装されている場合は、従来の仕組みよりも安全性が高くなる。

これらの方法の一歩先にあるのは、パスワードを完全になくすこと。WebAuthentication規格 `WebAuthn` は、まさにこれを実現している。iOS 15とmacOS Montereyには、この技術のプレビュー版が搭載されており、パスワードの代わりとして利用できる。

パスワードのない未来の実現に向けて業界全体で取り組んでいルガ、すでに持っているインフラのセキュリティを向上させるための措置をとることは、大きな価値があり、今後もしばらくはそうするであろう。人々がオンラインでより安全に過ごすためにできることはたくさんあります。

その一つが、SMSによる検証コードの配信。時間ベース検証コードの採用を検討している場合でも、SMSでコードを送信する必要があるかもしれない。

iOS 14とmacOS Big Surでは、メッセージにドメインバインディングを追加することで、SMSコードをよりフィッシングに強いものにする簡単な仕組みを紹介した。ドメインバインディングとは、このメッセージのコードが特定のドメイン向けであることをAutoFillに伝える方法。コードがこのようにバインドされていると、バインドされているドメインがWebページのドメインやアプリの関連ドメインの1つと一致する場合にのみ、AutoFillはコードを提供する。アプリでは、関連ドメインやユニバーサルリンクと同じ仕組みで機能する。なので、これらの技術に対応したアプリの設定が済んでいれば、ドメインバインディングを追加する準備は終わっている。

これについては、「ドメインバインディングによるSMSコードのセキュリティ強化」という記事で紹介している。
