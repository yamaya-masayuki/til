# Swift 6で導入予定の並列性対応

[Swift Concurrency Roadmap](https://forums.swift.org/t/swift-concurrency-roadmap/41611)より

## 動機となる例

今日、並行処理を推奨する基本的なパターンは良いものです。ロックではなくキューで
データを保護し、スレッドをブロックするのではなく非同期コールバックで遅延して処
理結果を返すように伝えています。

しかし、これらのことを手動で行うのはひどく、エラーが発生しやすいものです。これ
らのパターンを示す次のコードを考えてみます:

```swift
internal func refreshPlayers(completion: (() -> Void)? = nil) {
  refreshQueue.async {
    self.gameSession.allPlayers { players in
      self.players = players.map(\.nickname)
      completion?()
    }
  }
}
```

このコードについては、3つの所見があります:

* **儀式が多すぎます**。この関数は基本的には関数を呼び出して結果を変換してプロ
  パティに代入するだけです。しかし、キューや完了ハンドラには余計な作業が多すぎ
  て、それが見えなくなってしまいます。

* この余計な儀式があると、バグがが混入しやすくなります。
  完了ハンドラの中に`self.prayer`プロパティへの直接の代入があります。
  それはどのスレッドで行われるのか？自明ではありません。
  これはデータ競合の可能性があります: コールバックは、代入を行う前に正しいキュ
  ーにディスパッチする必要があるかもしれません。おそらくこれは `allPlayers` に
  よって処理されているのでしょうが、このコードがスレッドセーフであるかどうかは
  ローカルでは判断できません。

* このコードは**不必要に非効率的です**。複数の関数オブジェクトを個別に割り当て
  る必要があります。これらの関数で使用される`self`のような参照は、それらの中に
  コピーされなければならず、余分な参照カウント操作が必要になります。関数は複数
  回実行されることもあれば、全く実行されないこともあり、コンパイラがこれらのコ
  ピーを避けることができないこともしばしばあります。

そして、これらの問題は不可避的に結びついています。
非同期コールバックは最終的には常に一度だけ正確に実行されるので、恒久的な参照サ
イクルに参加することができません（原文理解できず）。
Swiftはこのことを知らないので、クロージャの中で明示的に`self`を必要とします。プ
ログラマの中には、反射的に`[weak self]`を追加することでこれに対応する人もいます。
このような関数は、`self`が`nil`のときに即リターンすることが多く、任意の量のコー
ドがスキップされている可能性があるため、その正しさについて推論することが難しく
なります。

ですから、ここで示されているパターンは良いのですが、Swiftで表現すると重要な構造
が失われてしまい、問題が生じます。
解決策は、これらのパターンを言語に持ち込むことです。そうすれば、陳腐な表現を減
らし、言語がパターンを安全なものにすることができ、バグを排除し、プログラマーは
並行処理をより広く使う自信を持つことができるようになります。また、同時実行コー
ドのパフォーマンスを向上させる機会も得られるでしょう。

ここで、私たちが提案した新しい構文を使って上記のコードを書き換えてみます:

```swift
internal func refreshPlayers() async {
  players = await gameSession.allPlayers().map(\.nickname)
}
```

この例で注意すべきこと:

* `refreshPlayers`は `async` 関数である。
* `allPlayers` もまた`async`関数であり、結果は完了ハンドラを経由して渡す代わり
  ににそのまま返す。
* これにより、結果値に直接`map`関数を呼び出す結合式(expression composition)を使
  うことができる。
* `await` キーワードは `allPlayers`を呼び出す式の前に現れる。これは、
  `refreshPlayers`関数がここで中断(suspend)する事を示している。
* `await` は `try` と同様に動作する。これは、中断可能な式の開始時に一度だけ現れ
  ればよく、その式の中で中断可能なすべての呼び出しの前に記述する必要はありませ
  ん。
* `self`をキャプチャするためのクロージャエスケープが必要ないため、プロパティに
  アクセスするための、明示的な `self.` は取り除かれています。
* `allPlayers` プロパティと `players`へのアクセスでデータ競合になることはありません。

最後の注意点がどのようにして達成されるかを理解するためには、レイヤーを一歩踏み
出して、キューがどのようにして状態を保護するために使用されるかを見なければなり
ません。

元のコードは、内部状態を保護するために`refreshQueue`を使用するクラス上のメソッ
ドでした:

```swift
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession
  var refreshQueue = DispatchQueue(label: "PlayerRefresh")

  func refreshPlayers(completion: (() -> Void)? = nil) { ... }
}
```

これは一般的なパターンです: プライベートキューを持つクラスと、キュー上でしかア
クセスできないはずのいくつかのプロパティを持つクラスです。私たちは、この手動の
キュー管理をアクタークラスに置き換えます:

```swift
actor class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async { ... }
}
```

この例で注意すべきこと:

* クラスをアクタ宣言することは、クラスにプライベートキューを与え、そのキューを
  介してそのプライベート状態へのすべてのアクセスを同期させることに似ています。
* この同期はコンパイラで理解できるようになったので、キューを使って状態を保護す
  ることを忘れてはいけません: コンパイラは、クラスのメソッドの中でキュー上で実
  行されていることを確認し、それらのメソッドの外で状態にアクセスすることを
  防ぎます。
* コンパイラがこれを行うことができるようになるため、メソッドが別のアクタで非同
  期関数を呼び出して開始する場合のように、よりスマートに同期を最適化することが
  できます。

アクタとその関数やプロパティの間にこのような静的な関係を持つことで、アクタに対
するデータの分離を強制し、データ競合を排除することができます。アクタのプロパテ
ィに安全にアクセスできるコンテキストにいるかどうかを静的に知ることができ、そう
でない場合はコンパイラがそのコンテキストへの切り替えを処理します。

上ではアクタークラスを示しましたが、ここではプロパティとコードのセットがしっか
りとカプセル化されています。しかし、今日のUIプログラミングの手法では、多くの場
合、コードを多数のクラスに分散させ、1つのメインスレッドから使用することになって
います。そのメインスレッドもまた一種のアクタです — グローバルアクタと呼びます。

クラスや関数を、そのアクタに関連付けられているものとして属性でマークすることが
できます。コンパイラはどこからでもこのクラスを参照できますが、実際にこのメソッ
ドを呼び出すには UI アクタ上にいる必要があります。

そこで、`PlayerRefreshController`のすべてのアクションがグローバルUIアクター上で
実行されることが適切であるとすれば、次のように表現することになります:

```swift
@UIActor
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async {  ...  }
}
```

## 1stフェーズのための提案

1stフェーズでは、安全性の利点を導入します。ユーザはグローバル変数をグローバルア
クタで保護し、アクタクラスに変換することでクラスメンバを保護することができるよ
うになります。特定のキューへのアクセスを必要とするフレームワークは、グローバル
アクタを定義し、それに対してデフォルトのプロトコルを定義することができます。

このステージでは、アクタ隔離の重要なケースがいくつかを導入します:

```swift
actor class MyActor {
  let immutable: String = "42"
  var mutableArray: [String] = []

  func synchronousFunction() {
    mutableArray += ["syncFunction called"]
  }
}

extension MyActor {
  func asyncFunction(other: MyActor) async {
    // できる: アクタは、その拡張において内部状態にアクセスできる
    self.mutableArray += ["asyncFunction called"]
  
    // できる: 不変メモリはそのアクタの外部からアクセスできる
    print(other.immutable)

    // できない: アクタは他のアクタの可変状態にアクセスできない
    otherActor.mutableArray += ["not allowed"]

    // できない: 読むか書くかのどちらか
    print(other.mutableArray.first)
    
    // できる: async関数は他アクタのasync関数から呼び出せる
    await other.asyncFunction(otherActor: self)
    
    // できない: アクタの外側からは非同期関数のみ呼び出せる
    other.synchronousFunction()
  }
}
```

アクタと`async`関数は新しい機能なので、これらの強制はソースコードを壊すことはありません。

## アクター隔離(Actor Isolation)と2ndフェーズ

アクタの導入後も、グローバル変数や参照型の値を介する事で競合状態の可能性は存在します:

```swift
var racyGlobal: [String] = []

@MyGlobalActor
var safeGlobal: [String] = []

class PlainOldClass {
  var unprotectedState: String = []
}

actor class RacyActor {
  let immutableClassReference: PlainOldClass

  func racyFunction(other: RacyActor) async {
    // 保護: グローバル変数はグローバル・アクタで保護される
    safeGlobal += ["Safe access"]
  
    // 暴露: グローバル変数はアクタ内では保護されない
    racyGlobal += ["Racy access"]
    
    // 暴露: racyPropertyは不変ですが参照型です。何故なら、暴露されされ共有され
    // たミュータブル型へのアクセスをできるようにするためです
    other.takeClass(immutableClassReference)
  }
  
  func takeClass(_ plainClass: PlainOldClass) {
    plainClass.unprotectedState += ["Racy access"]  
  }
}
```

1stフェーズでは、Swiftの現在のデフォルトの動作を維持することを意図しています:
グローバル変数とクラスコンポーネントのメモリはデータ競合から保護されていません。
したがって、このメモリのデフォルトは `actor unsafe` です。
これは現在のSwiftのデフォルトなので、この1st段階を有効にすることはソース変更を
強制しません。

2ndフェーズでは、さらなる機能の導入により、完全に隔離されたアクタを扱うためのツ
ールのフルセットが提供されます。
これらの中で最も重要なのは、型を`actor local`に制限する機能です。
型が`actor local`とマークされている場合、コンパイラはアクタ間で型が渡されるのを
防ぎます。その代わり、境界を越えて渡される前に、参照は何らかの方法でクローン/
共有解除される必要があります。

これにより、デフォルトの変更が可能になります:

* グローバル変数は、グローバルアクタで保護されているか、`actor unsafe`とマーク
  されている必要があります。
* クラス（およびクラス参照を含む型）は、デフォルトでは `actor unsafe` 状態から
  `actor local` に変更されます。

このデフォルトの変更は**ソース変更を必要**とし、言語モードによって拒否ができる
ように必要があるでしょう。
ミュータブルなグローバル変数に触れたり、アクタの境界を越えてクラス参照を共有す
るコードは、基本的にデータ競合から安全であることを示すことが出来ず、そのコード
（および将来書かれるコード）を変更する必要があります。
このソース変更が負担にならないことが望まれます:

* それは、グローバル変数の使用を最小限に抑えることが期待されており、ほとんどのグローバル変数はグローバルアクタによって保護できます;
* クラスがアクタの境界を越えて共有されない限り、`actor local` アノテーションはアクタ内のコードに影響を与えないはずです。
* 境界を越えて参照を渡さなければならない場合、言語はこれを明確にし、解決策をシンプルにしなければなりません。
* 値型の使用をさらに奨励し、簡素化することで、アクターの境界を越えてクラスを共有する必要性を減らすことができます。
* この2つのフェーズの間、ユーザーがコードにアクタやasync関数を組み込む機会を与え、完全隔離の準備をします。

1stフェーズのスピード感とは異なり、2ndフェーズで必要とされる言語機能は、最初は
Swiftフォーラムの進化の議論セクションで議論のために提起されます。
2ndフェーズのアプローチの主要な推進力の1つは、完全な隔離モデルに移行する前に、
Swiftユーザーにasync関数やアクタに慣れるための時間を与えたいということです。
大規模な作業コードベースをアクタやasync関数へ移植した経験が、アクタの完全隔離を
強制するために必要な機能を教えてくれることが期待されています。
このフィードバックは、2ndフェーズでの機能の議論に役立つはずです。

2ndフェーズで議論されるであろう機能は、以下です:

* 型に対する `actorlocal` 制限の導入
* `mutableIfUnique`クラス型を介した正しい"コピーオンライト"型を保証するためのコンパイラのサポート
* 属性を使用したアクタ隔離のオプトアウト、例えばスレッド安全性が他の手段で処理されている場合

## 概念の用語集

以下は設計全体で使用される基本的概念であり、ここで簡単に定義しておきます:

* **同期関数 (synchronous function)**は、Swiftプログラマーがすでに慣れ親しんで
  いる関数です。
* **スレッド**とは、基礎プラットフォームのスレッドの概念を指します。
  プラットフォームは様々ですが、基本的な特徴を共有する傾向があります。真の同時
  実行にはプラットフォーム・スレッドの作成が必要ですが、プラットフォーム・スレ
  ッドの作成と実行にはコストがかかります。
  Cの関数呼び出しや通常のSwift同期関数では、プラットフォーム・スレッドの使用が
  必要です。
* **非同期関数 (asynchronous function)**は、中断なしに完了まで実行する必要のな
  い新しい種類の関数です。
  割り込みが発生すると、関数は中断されます。非同期関数がスレッドを手放す地点が
  中断地点です。
* **タスク**とは、非同期的に実行される操作のことです。
  すべての非同期関数は、あるタスクの一部として実行されます。
  非同期関数が別の非同期関数を呼び出した場合、呼び出しがアクタを変更しなければ
  ならない場合でも、その呼び出しは同じタスクの一部として実行されます。
  タスクは非同期関数のためのスレッドに相当します。
* 非同期関数は**子タスク**を作成することができます。子タスクは親タスクの優先度など
  の構造の一部を継承しますが、親タスクと同時に実行することができます。
  しかし、この同時実行には制限があります。子タスクを作成する関数は、子タスクが
  終了するのを待ってから戻らなければなりません。
* プログラムが独立した並行作業を開始して、そのSpawning Contextを長持ちさせるこ
  とができるようにしたい場合は、拘束された子タスクではなく、
  **分離 (detached)タスク**を使用します。
* **部分タスク**とは、スケジューリング可能な作業の単位です。タスクの中で現在実
  行中の関数が中断されたとき、それが部分タスクの終了であり、タスク全体の作業を
  継続するために新しい部分タスクが作成されます。
* **実行子 (executor)**とは、部分タスクの提出を受け付け、それらを実行するための
  スレッドを手配するサービスです。現在実行中の非同期関数は、常に実行中の実行子
  を知っています。もし実行子に提出された部分タスクが決して同時に実行されない場
  合は、排他的と呼ばれます。
* **アクタ**は、コードを実行することができるプログラムの独立した部分です。
  アクタは一度に一つのコードしか実行できません -- つまり、それは排他的な実行子
  として機能します -- しかし、実行されるコードは他のアクタによって実行されるコ
  ードと同時に実行することができます。
* アクタは、そのアクタによってのみアクセスできる保護された状態を持つことができ
  ます。これを実現するシステムは**アクタ隔離 (isolation)**と呼ばれています。
  長期的な目標は、Swiftがデフォルトでアクタ隔離を保証することです。
* **アクタクラス**は参照型であり、各インスタンスは個別のアクタです。
  その保護された状態はインスタンスのプロパティであり、アクタ関数はインスタンス
  のメソッドです。
* **グローバルアクタ**はグローバルオブジェクトです。
  その保護された状態とアクタ関数は多くの異なる型にまたがっているかもしれません。
  これらはアクタ固有属性でマークでき、多くの場合、Swiftはこれを推論することがで
  きます。
