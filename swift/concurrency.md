# Swift 6で導入予定の並列性対応

[Swift Concurrency Roadmap](https://forums.swift.org/t/swift-concurrency-roadmap/41611)の勝手訳です。

私たちの目標は、Swiftでの並行プログラミングを便利に、効率的に、そして安全にすることです。
この文書では、非同期関数やアクタの実装を通じて、このようなことを実現するために提案されている、言語に対するいくつかの追加や変更について概説します。
これらの追加は個別に提案されますが、多くの場合はお互いに依存しています。このドキュメントはそれらを結合するためのものです。
複数の可能性のある方向性や、場合によってはありそうもない方向性を記述するマニフェストとは異なり、このドキュメントではSwiftの並列性に取り組むための単一の意図された計画を記述しています。

これらの変化の最終状態は:

* 非同期プログラミングを便利で明確なものにします。
* Swiftの開発者が従うことができる標準的な言語ツールと技術のセットを提供する。
* コンパイル時情報を高めることで、非同期コードのパフォーマンスを向上させます。
* Swiftがメモリの安全性の問題を排除するのと同じように、データ競合やデッドロックを排除します。

これらの機能の導入は、複数のSwiftリリースにまたがって行われます。
機能は大きく分けて2つのフェーズで導入されます。
1stフェーズでは、非同期構文とアクタ型が導入されます。これにより、ユーザーはアクタを中心にコードを整理し、データ競合を減らすことができますが、データ競合を排除することはできません。
2ndフェーズでは、データ競合を排除してアクタの完全隔離を強制し、隔離を実用的にするために必要なアクタの効率的で人間工学的な相互運用を可能にするための多くの機能を用いて、データ競合を排除します。

ロードマップとして、この文書では、これらの提案と同じレベルの詳細には触れていません。また、2ndフェーズの機能についても議論していますが、この分野の詳細な提案は、1stフェーズがより明確に定義されるまで待つことになるでしょう。

非同期ストリーム、ループの並列化、分散アクタなど、このドキュメントでは取り上げていない関連トピックが多数あります。
これらの機能の多くは、このロードマップで説明されている内容を補完するものであり、いつでも導入される可能性があります。

## 動機となる例

今日、並行処理を推奨する基本的なパターンは良いものです。ロックではなくキューでデータを保護し、スレッドをブロックするのではなく非同期コールバックで遅延して処理結果を返すように伝えています。

しかし、これらのことを手動で行うのはひどく、エラーが発生しやすいものです。これらのパターンを示す次のコードを考えてみます:

```swift
internal func refreshPlayers(completion: (() -> Void)? = nil) {
  refreshQueue.async {
    self.gameSession.allPlayers { players in
      self.players = players.map(\.nickname)
      completion?()
    }
  }
}
```

このコードについては、3つの所見があります:

* **儀式が多すぎます**。
  この関数は基本的には関数を呼び出して結果を変換してプロパティに代入するだけです。
  しかし、キューや完了ハンドラには余計な作業が多すぎて、それが見えなくなってしまいます。

* この余計な儀式があると、バグがが混入しやすくなります。
  完了ハンドラの中に`self.prayer`プロパティへの直接の代入があります。
  それはどのスレッドで行われるのか？自明ではありません。
  これはデータ競合の可能性があります: コールバックは、代入を行う前に正しいキューにディスパッチする必要があるかもしれません。
  おそらくこれは `allPlayers` によって処理されているのでしょうが、このコードがスレッドセーフであるかどうかはローカルでは判断できません。

* このコードは**不必要に非効率的です**。
  複数の関数オブジェクトを個別に割り当てる必要があります。
  これらの関数で使用される`self`のような参照は、それらの中にコピーされなければならず、余分な参照カウント操作が必要になります。
  関数は複数回実行されることもあれば、全く実行されないこともあり、コンパイラがこれらのコピーを避けることができないこともしばしばあります。

そして、これらの問題は不可避的に結びついています。
非同期コールバックは最終的には常に一度だけ正確に実行されるので、恒久的な参照サイクルに参加することができません（原文理解できず）。
Swiftはこのことを知らないので、クロージャの中で明示的に`self`を必要とします。プログラマの中には、反射的に`[weak self]`を追加することでこれに対応する人もいます。
このような関数は、`self`が`nil`のときに即リターンすることが多く、任意の量のコードがスキップされている可能性があるため、その正しさについて推論することが難しく
なります。

ですから、ここで示されているパターンは良いのですが、Swiftで表現すると重要な構造が失われてしまい、問題が生じます。
解決策は、これらのパターンを言語に持ち込むことです。そうすれば、陳腐な表現を減らし、言語がパターンを安全なものにすることができ、バグを排除し、プログラマーは並行処理をより広く使う自信を持つことができるようになります。また、同時実行コードのパフォーマンスを向上させる機会も得られるでしょう。

ここで、私たちが提案した新しい構文を使って上記のコードを書き換えてみます:

```swift
internal func refreshPlayers() async {
  players = await gameSession.allPlayers().map(\.nickname)
}
```

この例で注意すべきことは…:

* `refreshPlayers` は `async` 関数である。
* `allPlayers` もまた `async` 関数であり、結果は完了ハンドラを経由して渡す代わりににそのまま返す。
* これにより、結果値に直接 `map` 関数を呼び出す結合式(expression composition)を使うことができる。
* `await` キーワードは `allPlayers` を呼び出す式の前に現れる。これは、 `refreshPlayers` 関数がここで中断(suspend)する事を示している。
* `await` は `try` と同様に動作する。これは、中断可能な式の開始時に一度だけ現れればよく、その式の中で中断可能なすべての呼び出しの前に記述する必要はありません。
* `self` をキャプチャするためのクロージャエスケープが必要ないため、プロパティにアクセスするための、明示的な `self.` は取り除かれています。
* `allPlayers` プロパティと `players` へのアクセスでデータ競合になることはありません。

最後の注意点がどのようにして達成されるかを理解するためには、レイヤーを一歩踏み出して、キューがどのようにして状態を保護するために使用されるかを見なければなりません。

元のコードは、内部状態を保護するために `refreshQueue` を使用するクラス上のメソッドでした:

```swift
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession
  var refreshQueue = DispatchQueue(label: "PlayerRefresh")

  func refreshPlayers(completion: (() -> Void)? = nil) { ... }
}
```

これは一般的なパターンです:
プライベートキューを持つクラスと、キュー上でしかアクセスできないはずのいくつかのプロパティを持つクラスです。
私たちは、この手動のキュー管理をアクタークラスに置き換えます:

```swift
actor class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async { ... }
}
```

この例で注意すべきこと:

* クラスをアクタ宣言することは、クラスにプライベートキューを与え、そのキューを介してそのプライベート状態へのすべてのアクセスを同期させることに似ています。
* この同期はコンパイラで理解できるようになったので、キューを使って状態を保護することを忘れてはいけません: コンパイラは、クラスのメソッドの中でキュー上で実行されていることを確認し、それらのメソッドの外で状態にアクセスすることを防ぎます。
* コンパイラがこれを行うことができるようになるため、メソッドが別のアクタで非同期関数を呼び出して開始する場合のように、よりスマートに同期を最適化することができます。

アクタとその関数やプロパティの間にこのような静的な関係を持つことで、アクタに対するデータの分離を強制し、データ競合を排除することができます。
アクタのプロパティに安全にアクセスできるコンテキストにいるかどうかを静的に知ることができ、そうでない場合はコンパイラがそのコンテキストへの切り替えを処理します。

上ではアクタークラスを示しましたが、ここではプロパティとコードのセットがしっかりとカプセル化されています。
しかし、今日のUIプログラミングの手法では、多くの場合、コードを多数のクラスに分散させ、1つのメインスレッドから使用することになっています。
そのメインスレッドもまた一種のアクタです — グローバルアクタと呼びます。

クラスや関数を、そのアクタに関連付けられているものとして属性でマークすることができます。
コンパイラはどこからでもこのクラスを参照できますが、実際にこのメソッドを呼び出すには UI アクタ上にいる必要があります。

そこで、`PlayerRefreshController`のすべてのアクションがグローバルUIアクター上で実行されることが適切であるとすれば、次のように表現することになります:

```swift
@UIActor
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async {  ...  }
}
```

## 1stフェーズのための提案

1stフェーズでは、安全性の利点を導入します。
ユーザはグローバル変数をグローバルアクタで保護し、アクタクラスに変換することでクラスメンバを保護することができるようになります。
特定のキューへのアクセスを必要とするフレームワークは、グローバルアクタを定義し、それに対してデフォルトのプロトコルを定義することができます。

このステージでは、アクタ隔離の重要なケースがいくつかを導入します:

```swift
actor class MyActor {
  let immutable: String = "42"
  var mutableArray: [String] = []

  func synchronousFunction() {
    mutableArray += ["syncFunction called"]
  }
}

extension MyActor {
  func asyncFunction(other: MyActor) async {
    // できる: アクタは、その拡張において内部状態にアクセスできる
    self.mutableArray += ["asyncFunction called"]
  
    // できる: 不変メモリはそのアクタの外部からアクセスできる
    print(other.immutable)

    // できない: アクタは他のアクタの可変状態にアクセスできない
    otherActor.mutableArray += ["not allowed"]

    // できない: 読むか書くかのどちらか
    print(other.mutableArray.first)

    // できる: async関数は他アクタのasync関数から呼び出せる
    await other.asyncFunction(otherActor: self)

    // できない: アクタの外側からは非同期関数のみ呼び出せる
    other.synchronousFunction()
  }
}
```

アクタと`async`関数は新しい機能なので、これらの強制はソースコードを壊すことはありません。

## アクター隔離(Actor Isolation)と2ndフェーズ

アクタの導入後も、グローバル変数や参照型の値を介する事で競合状態の可能性は存在します:

```swift
var racyGlobal: [String] = []

@MyGlobalActor
var safeGlobal: [String] = []

class PlainOldClass {
  var unprotectedState: String = []
}

actor class RacyActor {
  let immutableClassReference: PlainOldClass

  func racyFunction(other: RacyActor) async {
    // 保護: グローバル変数はグローバル・アクタで保護される
    safeGlobal += ["Safe access"]
  
    // 保護しない: グローバル変数はアクタ内では保護されない
    racyGlobal += ["Racy access"]
    
    // 保護しない: racyPropertyは不変ですが参照型です。何故なら、共有された保護
    // されないミュータブル型へアクセスできるようにするためです
    other.takeClass(immutableClassReference)
  }
  
  func takeClass(_ plainClass: PlainOldClass) {
    plainClass.unprotectedState += ["Racy access"]  
  }
}
```

1stフェーズでは、Swiftの現在のデフォルトの動作を維持することを意図しています:
グローバル変数とクラスコンポーネントのメモリはデータ競合から保護されていません。
したがって、このメモリのデフォルトは `actor unsafe` です。
これは現在のSwiftのデフォルトなので、この1st段階を有効にすることはソース変更を強制しません。

2ndフェーズでは、さらなる機能の導入により、完全に隔離されたアクタを扱うためのツールのフルセットが提供されます。
これらの中で最も重要なのは、型を`actor local`に制限する機能です。
型が`actor local`とマークされている場合、コンパイラはアクタ間で型が渡されるのを防ぎます。その代わり、境界を越えて渡される前に、参照は何らかの方法でクローン/共有解除される必要があります。

これにより、デフォルトの変更が可能になります:

* グローバル変数は、グローバルアクタで保護されているか、`actor unsafe`とマークされている必要があります。
* クラス（およびクラス参照を含む型）は、デフォルトでは `actor unsafe` 状態から `actor local` に変更されます。

このデフォルトの変更は**ソース変更を必要**とし、言語モードによって拒否ができるように必要があるでしょう。
ミュータブルなグローバル変数に触れたり、アクタの境界を越えてクラス参照を共有するコードは、基本的にデータ競合から安全であることを示すことが出来ず、そのコード（および将来書かれるコード）を変更する必要があります。
このソース変更が負担にならないことが望まれます:

* それは、グローバル変数の使用を最小限に抑えることが期待されており、ほとんどのグローバル変数はグローバルアクタによって保護できます;
* クラスがアクタの境界を越えて共有されない限り、`actor local` アノテーションはアクタ内のコードに影響を与えないはずです。
* 境界を越えて参照を渡さなければならない場合、言語はこれを明確にし、解決策をシンプルにしなければなりません。
* 値型の使用をさらに奨励し、簡素化することで、アクターの境界を越えてクラスを共有する必要性を減らすことができます。
* この2つのフェーズの間、ユーザーがコードにアクタやasync関数を組み込む機会を与え、完全隔離の準備をします。

1stフェーズのスピード感とは異なり、2ndフェーズで必要とされる言語機能は、最初は Swiftフォーラムの進化の議論セクションで議論のために提起されます。
2ndフェーズのアプローチの主要な推進力の1つは、完全な隔離モデルに移行する前に、Swiftユーザーにasync関数やアクタに慣れるための時間を与えたいということです。
大規模な作業コードベースをアクタやasync関数へ移植した経験が、アクタの完全隔離を強制するために必要な機能を教えてくれることが期待されています。
このフィードバックは、2ndフェーズでの機能の議論に役立つはずです。

2ndフェーズで議論されるであろう機能は、以下です:

* 型に対する `actorlocal` 制限の導入
* `mutableIfUnique`クラス型を介した正しい"コピーオンライト"型を保証するためのコンパイラのサポート
* 属性を使用したアクタ隔離のオプトアウト、例えばスレッド安全性が他の手段で処理されている場合

## 概念の用語集

以下は設計全体で使用される基本的概念であり、ここで簡単に定義しておきます:

* **同期関数 (synchronous function)**は、Swiftプログラマーがすでに慣れ親しんでいる関数です。
* **スレッド**とは、基礎プラットフォームのスレッドの概念を指します。
  プラットフォームは様々ですが、基本的な特徴を共有する傾向があります。
  真の同時実行にはプラットフォーム・スレッドの作成が必要ですが、プラットフォーム・スレッドの作成と実行にはコストがかかります。
  Cの関数呼び出しや通常のSwift同期関数では、プラットフォーム・スレッドの使用が必要です。
* **非同期関数 (asynchronous function)** は、中断なしに完了まで実行する必要のない新しい種類の関数です。
  割り込みが発生すると、関数は中断されます。非同期関数がスレッドを手放す地点が中断地点です。
* **タスク** とは、非同期的に実行される操作のことです。
  すべての非同期関数は、あるタスクの一部として実行されます。
  非同期関数が別の非同期関数を呼び出した場合、呼び出しがアクタを変更しなければならない場合でも、その呼び出しは同じタスクの一部として実行されます。
  タスクは非同期関数のためのスレッドに相当します。
* 非同期関数は **子タスク** を作成することができます。子タスクは親タスクの優先度などの構造の一部を継承しますが、親タスクと同時に実行することができます。
  しかし、この同時実行には制限があります。子タスクを作成する関数は、子タスクが終了するのを待ってから戻らなければなりません。
* プログラムが独立した並行作業を開始して、そのSpawning Contextを長持ちさせることができるようにしたい場合は、拘束された子タスクではなく、
  **分離 (detached) タスク** を使用します。
* **部分タスク** とは、スケジューリング可能な作業の単位です。タスクの中で現在実行中の関数が中断されたとき、それが部分タスクの終了であり、タスク全体の作業を継続するために新しい部分タスクが作成されます。
* **実行子 (executor)** とは、部分タスクの提出を受け付け、それらを実行するためのスレッドを手配するサービスです。現在実行中の非同期関数は、常に実行中の実行子を知っています。もし実行子に提出された部分タスクが決して同時に実行されない場合は、排他的と呼ばれます。
* **アクタ** は、コードを実行することができるプログラムの独立した部分です。
  アクタは一度に一つのコードしか実行できません -- つまり、それは排他的な実行子として機能します -- しかし、実行されるコードは他のアクタによって実行されるコードと同時に実行することができます。
* アクタは、そのアクタによってのみアクセスできる保護された状態を持つことができます。これを実現するシステムは **アクタ隔離 (isolation)** と呼ばれています。
  長期的な目標は、Swiftがデフォルトでアクタ隔離を保証することです。
* **アクタクラス** は参照型であり、各インスタンスは個別のアクタです。
  その保護された状態はインスタンスのプロパティであり、アクタ関数はインスタンスのメソッドです。
* **グローバルアクタ**はグローバルオブジェクトです。
  その保護された状態とアクタ関数は多くの異なる型にまたがっているかもしれません。これらはアクタ固有属性でマークでき、多くの場合、Swiftはこれを推論することができます。
