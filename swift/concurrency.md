# Swift 6で導入予定の並列性対応

[Swift Concurrency Roadmap](https://forums.swift.org/t/swift-concurrency-roadmap/41611)より

## 動機となる例

今日、並行処理を推奨する基本的なパターンは良いものです。ロックではなくキューで
データを保護し、スレッドをブロックするのではなく非同期コールバックで遅延して処
理結果を返すように伝えています。

しかし、これらのことを手動で行うのはひどく、エラーが発生しやすいものです。これ
らのパターンを示す次のコードを考えてみる:

```swift
internal func refreshPlayers(completion: (() -> Void)? = nil) {
  refreshQueue.async {
    self.gameSession.allPlayers { players in
      self.players = players.map(\.nickname)
      completion?()
    }
  }
}
```

このコードについては、3つの所見があります:

* **儀式が多すぎます**。この関数は基本的には関数を呼び出して結果を変換してプロ
  パティに代入するだけです。しかし、キューや完了ハンドラには余計な作業が多すぎ
  て、それが見えなくなってしまいます。

* この余計な儀式があると、バグがが混入しやすくなります。
  完了ハンドラの中に`self.prayer`プロパティへの直接の代入があります。
  それはどのスレッドで行われるのか？自明ではありません。
  これはデータ競合の可能性があります: コールバックは、代入を行う前に正しいキュ
  ーにディスパッチする必要があるかもしれません。おそらくこれは `allPlayers` に
  よって処理されているのでしょうが、このコードがスレッドセーフであるかどうかは
  ローカルでは判断できません。

* このコードは**不必要に非効率的です**。複数の関数オブジェクトを個別に割り当て
  る必要があります。これらの関数で使用される`self`のような参照は、それらの中に
  コピーされなければならず、余分な参照カウント操作が必要になります。関数は複数
  回実行されることもあれば、全く実行されないこともあり、コンパイラがこれらのコ
  ピーを避けることができないこともしばしばあります。

そして、これらの問題は不可避的に結びついています。
非同期コールバックは最終的には常に一度だけ正確に実行されるので、恒久的な参照サ
イクルに参加することができません（原文理解できず）。
Swiftはこのことを知らないので、クロージャの中で明示的に`self`を必要とします。プ
ログラマの中には、反射的に`[weak self]`を追加することでこれに対応する人もいます。
このような関数は、`self`が`nil`のときに即リターンすることが多く、任意の量のコー
ドがスキップされている可能性があるため、その正しさについて推論することが難しく
なります。

ですから、ここで示されているパターンは良いのですが、Swiftで表現すると重要な構造
が失われてしまい、問題が生じます。
解決策は、これらのパターンを言語に持ち込むことです。そうすれば、陳腐な表現を減
らし、言語がパターンを安全なものにすることができ、バグを排除し、プログラマーは
並行処理をより広く使う自信を持つことができるようになります。また、同時実行コー
ドのパフォーマンスを向上させる機会も得られるでしょう。

ここで、私たちが提案した新しい構文を使って上記のコードを書き換えてみます:

```swift
internal func refreshPlayers() async {
  players = await gameSession.allPlayers().map(\.nickname)
}
```

この例で注意すべきこと:

* `refreshPlayers`は `async` 関数である。
* `allPlayers` もまた`async`関数であり、結果は完了ハンドラを経由して渡す代わり
  ににそのまま返す。
* これにより、結果値に直接`map`関数を呼び出す結合式(expression composition)を使
  うことができる。
* `await` キーワードは `allPlayers`を呼び出す式の前に現れる。これは、
  `refreshPlayers`関数がここで中断(suspend)する事を示している。
* `await` は `try` と同様に動作する。これは、中断可能な式の開始時に一度だけ現れ
  ればよく、その式の中で中断可能なすべての呼び出しの前に記述する必要はありませ
  ん。
* `self`をキャプチャするためのクロージャエスケープが必要ないため、プロパティに
  アクセスするための、明示的な `self.` は取り除かれています。
* `allPlayers` プロパティと `players`へのアクセスでデータ競合になることはありません。

最後の注意点がどのようにして達成されるかを理解するためには、レイヤーを一歩踏み
出して、キューがどのようにして状態を保護するために使用されるかを見なければなり
ません。

元のコードは、内部状態を保護するために`refreshQueue`を使用するクラス上のメソッ
ドでした:

```swift
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession
  var refreshQueue = DispatchQueue(label: "PlayerRefresh")

  func refreshPlayers(completion: (() -> Void)? = nil) { ... }
}
```

これは一般的なパターンです: プライベートキューを持つクラスと、キュー上でしかア
クセスできないはずのいくつかのプロパティを持つクラスです。私たちは、この手動の
キュー管理をアクタークラスに置き換えます:

```swift
actor class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async { ... }
}
```

この例で注意すべきこと:

* クラスをアクタであると宣言することは、クラスにプライベートキューを与え、その
  キューを介してそのプライベート状態へのすべてのアクセスを同期させることに似て
  います。
* この同期はコンパイラで理解できるようになったので、キューを使って状態を保護す
  ることを忘れてはいけません: コンパイラは、クラスのメソッドの中でキュー上で実
  行されていることを確認し、それらのメソッドの外で状態にアクセスすることを
  防ぎます。
* コンパイラがこれを行うことができるようになるため、メソッドが別のアクタで非同
  期関数を呼び出して開始する場合のように、よりスマートに同期を最適化することが
  できます。

アクタとその関数やプロパティの間にこのような静的な関係を持つことで、アクタに対
するデータの分離を強制し、データ競合を排除することができます。アクタのプロパテ
ィに安全にアクセスできるコンテキストにいるかどうかを静的に知ることができ、そう
でない場合はコンパイラがそのコンテキストへの切り替えを処理します。

上ではアクタークラスを示しましたが、ここではプロパティとコードのセットがしっか
りとカプセル化されています。しかし、今日のUIプログラミングの手法では、多くの場
合、コードを多数のクラスに分散させ、1つのメインスレッドから使用することになって
います。そのメインスレッドもまた一種のアクタです — グローバルアクタと呼びます。

クラスや関数を、そのアクタに関連付けられているものとして属性でマークすることが
できます。コンパイラはどこからでもこのクラスを参照できますが、実際にこのメソッ
ドを呼び出すには UI アクタ上にいる必要があります。

そこで、`PlayerRefreshController`のすべてのアクションがグローバルUIアクター上で
実行されることが適切であるとすれば、次のように表現することになります:

```swift
@UIActor
class PlayerRefreshController {
  var players: [String] = []
  var gameSession: GameSession

  func refreshPlayers() async {  ...  }
}
```

## 1stフェーズのための提案

TBD

## アクター隔離(Actor Isolation)と2ndフェーズ

TBD

### 1stフェーズ: 基本アクター隔離

TBD

### 2ndフェーズ: 完全アクター隔離

TBD

## 概念の用語集

TBD
